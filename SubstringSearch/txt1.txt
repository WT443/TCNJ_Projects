Service-Oriented Software Engineering (SOSE) 
By 
Warren Smith
CSC 415: Software Engineering 
11/1/2013 
Instructor: Dr. Pulimood
 
ABSTRACT
Service-oriented software engineering is a relatively new methodology that vastly is becoming more popular in the software development field. It is currently one of the most dominant design models used within the software community/industry and due to its potential it continues to grow in popularity. This paper takes a deeper look into what service-oriented software engineering is, what services are, how service-oriented architecture is involved, and finally the benefits and challenges of this software methodology. 
Keywords
Service-oriented software engineering (SOSE), Service-oriented architecture (SOA)
1.	INTRODUCTION
The world of software development is one that is always growing and constantly changing. Different design models are created to accommodate the needs that present themselves at that time. We currently live in an environment that is focused on the reuse of code already created to perform different and additional tasks. This focus lead to the relatively new and now dominant software methodology called “service-oriented software engineering”. Service-oriented software engineering (SOSE) is the development of software systems by utilizing a variety of reusable code pieces and putting them all together to accomplish the created system’s underlying task. Due to the way that SOSE functions it easily can be compared to component based software engineering. Component based software builds a system from reusable components, but service-oriented software does this and adds the ability to dynamically find needed services at run-time [Breivold and Larsson 2007]. The goal of this paper is to explain what a service is, the SOSE’s use of service-oriented architecture (SOA), design patterns, principles, and give more insight into the benefits and challenges presented when using a design model such as this. 
2.	SERVICES
To understand what SOSE is and how it works one must first understand what a service is. A service is a single building block that is used in service-oriented solutions. Multiple services are put together in a service-oriented design to create a software system.  What is considered a service depends solely on the method being used but services can be broken down into two main categories, software and business services. Software services represent encapsulated business and application logic while business services represent high-level business function units such as departments, teams, etc. For the purpose of explaining what a service is in more detail I will focus on the software services, as the business ones are not considered an outcome of service development tasks in SOSE methods [Alani and Baghdadi 2012].
Software services can be defined by their functionality which fall under two layers, infrastructure and capability. The infrastructure layer deals with an organization’s supporting distributed computing structure. This layer consists of both the communication and utility services. Communication services expose message transfer capabilities, for example message-routing. Utility services expose auxiliary support to other services like diagnosis and management. 
The capability layer deals with the services for an organization’s business logic and resources. This layer is made up of the task, process, data, application, hybrid, and external services. Task services expose the action centric business logic elements. Process services create other application services to make a business process. Data services represent the operations done on data and business entities. Application services expose the functionality of an application, such as an reengineered legacy system. Hybrid services are ones that contain both application and business logic functionalities. External services are ones that are provided by an external party [Alani and Baghdadi 2012].   
3.	SERVICE ORIENTED ARCHITECTURE (SOA)
3.1 Purpose
A core part of SOSE is the service-oriented interaction pattern, also known as the service-oriented architecture (SOA). The SOA is what enables a group of services to communicate and work with one another. Basically SOA is a way to design software that provides services to applications or other services through discoverable interfaces [Breivold and Larsson 2007]. To put it in perspective, say we have multiple services, each implementing one action. The services could be submitting an online application for an account, retrieving an online bank statement, modifying an online booking or airline ticket order, etc. With the use of a SOA the multiple services utilize defined protocols that describe how the services pass messages using description metadata, meaning “data about data”. 
The purpose of SOA is to allow developers to combine large, stand-alone code (services) to form ad hoc applications built almost completely off of previously existing software. The larger the services are the fewer amount of interfaces are needed to implement the functionality. Design questions come into play when talking about this though as the larger services may not be easily reused. So performance considerations need to be made in choosing the size of services that will be implemented. 
3.2 Design Concept
In defining the design concepts of SOA there are three main “actors” within its interaction pattern. These are defined as the service provider, service registry, and service requester. The service provider defines service descriptions for a collection of services, supplies the services with functionalities, and releases the descriptions of the services which make them discoverable. The service registry contains service descriptions and references to providers while also creating ways for those services to be discovered. The service requester is what calls the service provider. It searches the service registry for a specific service using a service interface. When the interface matches the criteria of what the service requester is asking for it makes a dynamic binding with the service provider, which connects the service and allows it to be interacted with [Breivold and Larsson 2007].           
 
Figure 1: Service Oriented Interaction Pattern

Since SOA is based off the concept of using services, the ability to reuse code in different ways throughout an application becomes possible. All that needs to be done is simply change the way a particular service communicates with other ones, instead of having to make physical code changes. For reasons such as this SOA design principles are used during software development and integration stages.
In terms of design strategy there are three possible methods used when implementing a SOA. First is the top-down approach, which identifies and implements required services using a web service or technology along those lines. Next is the bottom-up strategy, which is essentially the opposite of the previous method and focuses on existing legacy systems. This strategy identifies and implements services on an as-needed basis. The last one is the meet-in-the-middle strategy, which is an agile process incorporating service oriented design principles into a business environment. This strategy at the same time integrates service technologies into technical environments [Alani and Baghdadi 2012].
3.3 Types of SOA
When it comes to SOA there are four common types that are used to improve the concept of physical design. Having these different types make it a lot easier to have a standardized model and cohesion between services since the broad variety of them can now be broken down into smaller subsections. The four common types are as followed: service architecture, service composition architecture, service inventory architecture, and service-oriented enterprise architecture. 
Service architecture is the physical design of one service that it surrounded by all the resources could use. Examples of these resources would be items such as databases, software components, legacy systems, etc. It also is noted and recommended to include any service agents available because any change within it would directly affect messaging capabilities of the service. This architecture is for the most part used as a point of reference for evolving and monitoring any changes of a particular service.
In SOSE a main concept behind its service-oriented design is the fact that all the services are component based. The services composition architecture is the combining of the architectures for each service of a system. With this type of architecture internal details of a service are not included, just the service-level agreement is. A service level agreement (SLA) is a part of the service’s contract and is where that particular service is defined. This design does include secondary paths, such as error handling, which can bring more services into the current architecture being created if needed. 
The service inventory architecture type is one where all the services within it are used to automate business processes. By documenting the services from the business processes they automate it, which makes it easier to detect processing issues. This architecture is documented in a way that service candidates can be adjusted appropriately before their implementation. 
Finally, the service-oriented enterprise architecture is an umbrella type that combines the service, composition, and inventory types mentioned before. It also includes any enterprise-wide resource technology that can be accessed for any service. With this architecture enterprise standards can be applied and if any segments of it is not service-oriented they can be transformed in a way so that they can become accessible if needed. 
3.4 Principles
There have been multiple principles defined for using SOA in the SOSE methodology that help guide development, maintenance, and usage of the service-oriented design. The main principles can be broken down into three phases of the service- oriented design model, including: the analysis phase, the design phase, and the service realization phase. 
During the analysis phase the guidelines to consider are service autonomy, reusability, standardized contract definition, cohesion, coupling, and granularity. Service autonomy refers to the ability of a service to control the runtime environment, minimizing any unknown external problems to occur. Reusability is having a service that can be useful for more than one purpose so that is can be used over and over again in different systems. Service contracts are used to establish terms of engagement, providing technical constraints and requirements of a particular service [Breivold and Larsson 2007]. So the standardized contract definition principle refers to a contract’s content type and represents mutual agreements between a service provider and service consumers. The cohesion principle focuses on the strength of functional relevance that a service provides. Next, the coupling principle is for indicating how a service is related to other services within its process. The granularity principle refers to the functionality that each individual service implements [Alani and Baghdadi 2012]. 
During the next phase, the design phase, the principles defined are service discoverability, and service normalization. Service discoverability is designing a service that can be found as much as possible in a service-oriented design. This principle supports the avoidance of creating similar services by making sure that when a service is created it is detected before a redundant one is formed. The service normalization principle refers to services that are condensed to a form considered “normal” so that the risk of redundancy within it is minimized [Alani and Baghdadi 2012]. 
The last design phase used in talking about principles, the service realization phase, includes the following ones: service abstraction, composability, and standardization. Service abstraction is when the information contained in a service contract is limited to only what is required to obtain the service currently being looked at. Service composability, which is one of the core principles in an SOA, refers to services being effective components of one another despite size and/or complexity. The service standardization principle deals with the ability for software on multiple systems to be able to communicate with one another by sharing data [Alani and Baghdadi 2012]. 
4.	BENEFITS/CHALLENGES 
4.1 Benefits
There are many benefits to using a design model such as SOSE which is why it is becoming very popular in programming today.  Many people believe that using in using SOSE businesses can respond a lot quicker and in a more cost-efficient way when dealing with changes to marketing conditions. This software engineering methodology supports the reuse of high-level, full functioning code (services) rather than the lower-level class reuse capabilities previously existing. It also can simplify the connection between older existing software through its processes [Avgeriou and Kontogogos 2009]. 

 
Figure 2: Benefits chart of using SOSE 

SOSE is in a lot of ways more of an architectural evolution rather than something completely new. It uses the best practices from older architectures and combines them together to create a more high-powered version. With the introduction of services there are a wide variety of possibilities that could stem from utilizing this method. The biggest benefit of all is that this methodology is still relatively new and will continue to grow and improve as time goes on to cater to the needs of the programmer and client.  
4.2 Challenges
With the upside of something there are always concerns that are surrounded by it as well. SOSE is no different and is not perfect in any sense of the word. Due to the fact that SOSE is more of an evolution from previous architectures it means that some challenges from those past ones are inherited up. For example, requirement engineering is used in SOSE so the challenges faced with that also are faced within a service-oriented system. This means the issues pertaining to conflict resolution in requirements, requirement change and evolution, and the reuse of requirement models could pose a problem in service-oriented systems as well if not implemented right [Bano and Ikram 2010].
More direct concerns and issues can be identified in the SOSE methodology from its development, technology, and composition aspects. In the development process one must be careful with building from pre-existing services and separating the one needed with ones that aren’t. If not done properly redundant or even malicious services could be utilized in a system and ruin its functionality. From the technology point of view encapsulation could become a concern since SOSE only supports the black box version. This could lead to inflexibility down the road for services to be modified. With the last aspect of concern, the composition of a system, one must be aware of how the design time/run time mechanisms work and its predictability. In SOSE services are composed only at run time and several mechanisms exist to create the services, so when dealing with this a programmer has to make sure the right protocol is being used. In terms of predictability, due to its dynamic discovery and availability problems could occur when trying to predict the quality of services [Breivold and Larsson 2007].  
5.	CONCLUSION
The service-oriented software engineering methodology (SOSE) is a fast growing design concept that basically is an evolved state of previous architectures combined together. With a lot of similarities to component based software engineering as well as a unified process for design the idea behind SOSE is far from a new thing. The process of utilizing created services within a standardized service-oriented architecture (SOA) to have them communicate with one another dynamically leads to a lot of programming possibilities. The SOA’s purpose and implementation is complex and comprised of multiple concepts but the outcome of its process leads to a service-oriented design that produces many benefits. Despite the fact that there are concerns with using the SOSE methodology it provides the potential to have major stand-alone software available and reusable for multiple systems. As technology continues to get more advanced the design methods need to be able to handle the stronger software workload. The SOSE design method is proving to be a big step into this era of programing as it provides great design potential and continues to grow.  
